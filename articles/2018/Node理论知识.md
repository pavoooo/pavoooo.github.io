# Node理论知识

学习`Node.js`，只是简单的掌握api的使用是远远不够的。`Node.js`是基于异步的，非阻塞的事件模型驱动的。那什么是异步？与之相对的什么是同步？什么是阻塞，以及什么又是非阻塞呢？这些都是在学习`Node.js`过程中必须要掌握的要点。这里作一个简单的概括。

## 同步和异步

对于`同步`和`异步`，首先我们要明白的就是其针对的对象是谁？`同步`和`异步`是`进程`和`线程`的调用方式。
`同步`指的是在进程和线程发起调用的时候，会一直等待调用结束才会执行下一步的操作。但是，这里的等待并不是`cpu`的等待。操作系统一般会切换到另外一个进程或者线程上，等待调用结束后再切回到原来的进程或者线程上执行后面的操作。

而`异步`却恰恰相反。当发起一个`异步`的调用时，进程或者线程会继续执行后续的操作。当调用结束的时候，会通过一些方法来通知调用者对调用结果进行处理。

## 阻塞和非阻塞
`阻塞`和`非阻塞`时针对`IO`的状态而言的。`Node.js`是一个事件驱动的非阻塞模型。我们不能单纯的认为`阻塞 === 同步`，`非阻塞 === 异步`。其针对的对象是完全不同的，`同步`和`异步`是针对进程和线程而言的，而`阻塞`和`非阻塞`则是针对`IO操作`来说的。

那什么是`IO操作`呢？

**IO操作就是我们通常说的输入和输出操作，它是内存和设备之间复制数据的过程。**`Node.js`中的`IO操作`就是指在`libuv`库的支持下系统磁盘和网络进行交互的过程。

那`IO`操作的结果是如何返回给进程和线程的呢？

简单的说就是通过内核复制给调用的进程和线程的。在`linux`系统下，用户是没有办法直接访问内核空间的，通常内核会调用`copy_to_user`方法将内核中的数据传递给用户。大致的流程就是`IO`操作的数据会先被内核读取，然后内核通过一些操作将数据复制给用户进程。

**IO的编程模型**

操作系统在处理`IO`操作的时候所采取方式被称作编程模型。主要有如下几种编程模型。

- **阻塞IO(blocking io)**

IO的运行一般可以分为两个阶段：`准备数据`和`返回结果`。`阻塞型IO`会在进程发出一个系统调用的请求之后，进程就一直等待上述两个阶段完成，等拿到返回结果的时候再继续运行。

- **非阻塞IO(nonblocking io)**

和`阻塞型io`不同的是，`非阻塞型io`会在进程发起一个调用的时候，如果数据还没有准备就绪，就会马上返回一个结果告诉进程现在还没有就绪。用户的进程会不断查询内核的状态的，但这个过程依然是同步的。

- **IO multiplexing/Event Driven**

这种被称为`事件驱动IO`，也是通过`轮询`的方式来查询内核的状态。和`非阻塞IO`的一个显著区别就是：一个进程可能会管理多个IO请求，当某个IO有了调用结果之后，就会返回对应的结果。

- **Asynchronous IO**

这就是我们熟悉的`异步IO`编程模型。这种模型在进程发出调用的后，内核会立刻返回结果，进程也会继续做其他的事情，直到操作系统返回了数据，给用户进程发送一个信号。

## 单线程和多线程

`Node`只提供了`单线程`的支持，无法将程序运行在`多线程`中。所以，我们的代码只能运行在一个线程中，也就是我们通常说的`主线程`。我们无法在`Node`中开启多线程，但我们可以利用`多核cpu`的特点来派生出`多个进程`来达到相同的目的。

`Node`的底层并不是不能支持多线程的。`libuv`中是存在`线程池`的。`libuv`是`Node`中的跨平台的`异步io库`。为Node提供多平台的异步IO的支持。Node中的非阻塞IO以及事件循环的底层机制，都是通过libuv来实现的。

## 并行和并发

`并发`是假设有两队人在排队，但是只有一个取票机。为了公平起见，先由队列一排头的人上前取票，再由队列二排头的人上前取票。这样的在两个队列之间`来回切换`，两个队列都在向前移动，就达到了并发的目的。

`并行`同样是有两对人在排队，但不同的是开放了两台取票机。那么两个队列的人就都能够向前移动了，速度是一个窗口的两倍以上。

所以**并发就是为了计算机能够做更多的事情**，而**并行就是为了计算机能够更快的做事情**。*并行程序可以看作是并发程序的一种。*

`Node`也是支持`高并发`场景的。主要就是通过`异步+事件驱动`来实现的。异步可以在面对多个请求的时候不会阻塞，事件驱动可以在IO调用结束的时候，通过回调函数来处理结果。

## 回调函数

早期`node`处理异步事件的模型，就是`回调函数`风格式的。**回调函数可以被认为是被主进程挂起来的代码**。当主进程读取`任务队列`中异步事件的时候，如果发现已经完成的事件，就会在主进程中执行该事件对应的回调函数。所以，回调函数和主进程是在同一个层次的，当主进程发起一个底层的系统调用的时候，操作系统就会去执行这个系统调用。一旦系统调用结束，就又会回到主进程中调用其指定的回调。`node`中的回调遵循`error-first`的原则，如果调用失败，则回调函数的第一个参数就是其失败的错误对象，反之，则为`null`。

下面就是`node`中的一个简单的回调函数的例子：

```js
const fs = require('fs)

fs.readFile('./package.json', 'utf8', (err, data) => {
    if(err) {
        throw err
    }
    console.log(data)
})
```

在上面这个例子中，`fs.readFile`就可以看作是一个系统调用。当执行结束，也就是系统调用完成后，主线程就会执行对应的回调函数。

## 事件循环Event Loop

说起`Node.js`就不得不提到异步，提到异步，又不得不说`事件循环`。

通俗地讲，`事件循环`就是在程序启动期间运行的一个死循环，除此没有什么特别之处。`Node`的代码是运行在单线程中的，但是依然能够支持高并发，就是通过`事件循环`来实现的。所以，下面我们就来看看`Node`中的事件循环的相关内容。

我们说过`Node`的代码是运行在单线程环境下的。所以，事件循环同样是在单线程中运行的。客户端的`javascript`是通过`浏览器来实现事件循环`的，然而，Node的事件循环确是由底层的Libuv库来实现的。

Node的事件循环大致可以分为几个阶段：

![node](/blog/node1.png)

从上图中，我们可以看到`Node`中将事件循环分成了`6个阶段`。**每一个阶段都维护着一个回调函数的队列，在不同的阶段，事件循环会处理不同的事件。不同的事件也会被添加到事件循环的不同阶段。**下面是各个阶段的不同的工作：

- **timers**：用来处理`setTimeout`和`setInterval`方法的回调
- **I/O callbacks**: 大多数的回调方法会在这个阶段执行，除了`timers`，`close`，`setImmediate`事件的回调
- **idle, prepare**: 仅仅在内部使用
- **poll**: 轮询，这个阶段就是不断的检查有没有新的IO事件。时间循环可能会在这里造成阻塞
- **check**: 处理`setImmediate`的回调
- **close callbacks**: 处理一些`close`事件。比如`socket.on('close', function () {})`

知道了`Node`事件循环的几个过程，我们可以使用如下伪代码来表示事件循环的执行过程。


```js
while(true) {
    // ......
    run_timers();
    run_io_callbacks();
    run_idle();
    run_poll();
    run_check();
    run_close_callbacks();
    // ......
}   
```
上面代码中的每一次函数的调用都代表一个阶段的执行。如果事件循环现在进入了某一个阶段，那么就会把当前队列中的事件全部处理完毕后才会进入到下一个阶段。

下面是对各个阶段的详细介绍。（idle, prepare仅在内部使用，不作探讨）。

**1. timers阶段**

这个阶段主要是用来处理`定时器`相关的回调函数的。当一个定时器超时后，一个事件就会被加入到这个队列中，事件循环也会跳转到这个阶段来执行相应的回调函数。

我们知道，定时器一般可能不会被准时的触发，而是尽可能早的被调用。如果事件循环正在执行一个比较耗时的callback。那么定时器也只能等待这个callback执行完毕后才会被执行，也就是会发生阻塞的过程。所以，一般来说，`timers阶段`的任务是受到poll阶段的控制的。

`Node`中定时器主要有如下两种：

```js
setInterval()
setTimeout()
```

**2. IO callback阶段**

这个阶段是除了`timers`, `setImmediate`以及`close`事件回调的大多数回调方法的执行阶段。但事实上这个阶段只是用来执行`pending callback`的。

**3. poll阶段**

这个阶段的主要任务就是等待新的事件出现。node中使用`epoll`来获取新的事件。这个解阶段主要有两个步骤：
- 如果有到期的定时器，那么就会执行定时器的回调方法
- 处理`poll`阶段对应的事件队列中的事件
至于执行的方式，则会通过以下的判断：
- 如果`pol`l队列不为空，则事件循环就会按照顺序遍历执行队列中的回调函数，这个过程是同步执行的。
- 如果`poll`队列为空，又会进行如下的判读：
    - 如果当前代码定义了`setImmediate`方法，那么事件循环就会离开这个阶段，进入到`check`阶段去执行`setImmediate`方法定义的回调。
    - 如果当前代码中没有定义`setImmediate`方法，那么事件循环就会进入等待的状态，等待新的事件出现。这个阶段会通过轮询的方式来判断是否有新的事件出现。此外，还会检查是否有相应的定时器到达了时间，如果有，就会跳到`timers阶段`来执行这个定时器定义的回调方法。


**4. check阶段**

在`Node`中，`setImmediate`是一个特殊的方法。这个方法会占据事件循环的一个阶段，也可以说`check阶段`就是为了`setImmediate`方法设置的。一般来说，如果在`poll阶段`检查到了代码中定义了`setImmediate`相关的回调，那么事件循环就会从`poll阶段`跳转到`check阶段`执行。

**5. close阶段**

`Node`中的很多模块都是基于流的，一般这些模块都可以绑定一个`close`事件。比如`socket`的一个句柄被关闭了等。这些事件对应的回调方法会被添加到`close阶段`的队列中。`close阶段`是事件循环的最后一个阶段，当这个阶段执行完毕后，事件循环就会被进入到**下一轮**中。

下面是一个详细的例子来解释事件循环的详细的过程。


```js
const fs = require('fs')
const start = Date.now()

setTimeout(() => {
    const delay = Date.now() - start
    console.log(delay)
}, 100)

fs.readFile('./package.json', (err, data) => {
    const startCallback = Date.now()
    // 使用循环，阻塞进程100ms
    while (Date.now() - start < 100) {
        // do something
    }
})
```

上面的代码中涉及到了`setTimeout`和`readFile`两个异步操作。首先来看一下这段代码的执行过程，当代码开始执行的时候，事件循环也就进入了运行阶段。

事件循环会首先进入`timers阶段`，但是这个阶段对应的事件队列为空（因为100ms之后才会有事件发生），紧接着，事件循环会向下执行到了`poll阶段`，但是到目前为止还没有事件出现，而且，我们的代码中也没有定义`setImmediate`操作，所以事件循环便会在这个阶段进行轮询等待新的事件出现。

这里假设`readFile`的操作耗时90ms，那么当`readFile`读取文件的内容结束后就会触发一个事件，这个事件会被加入到`poll`队列中，这个时候，事件循环就会将该队列中的事件取出，准备执行其对应的callback。这里的callbakc会阻塞进程100ms。

所以，事件循环也是会被阻塞100ms的。这个时候的`timers队列`中也存在了相应的事件，但事件循环也是单线程执行的，所以会等到readFile的回调执行结束才会执行`timers阶段`的队列。如果`readFile`的回调是一个死循环，那么`timers阶段`的队列是永远不会执行的，也就是说`setTimeout`指定的回调函数是永远不会被执行的。

当`readFile`的事件回调执行结束后，事件循环就会被切换到`timers阶段`，接着就会取出`timers队列`中的事件执行对应的回调方法。

**process.nextTick**

`process.nextTick`的意思就是定义一个异步的动作，并且让这个动作在事件循环的当前阶段结束后执行。基于这个定义，我们的事件循环的执行阶段可以使用如下伪代码表示：
```js
while(true) {
    // ......
    run_timers();
    
    run_nextTick();
    
    run_io_callbacks();
    
    run_nextTick();
    
    run_idle();
    
    run_nextTick();
    
    run_poll();
    
    run_nextTick();
    
    run_check();
    
    run_nextTick();
    
    run_close_callbacks();
    
    run_nextTick();
    
    // ......
}   
```
但是，`process.nextTick`并不是事件循环的一部分。但它的回调方法也是由事件循环调用的。这个方法定义的回调函数会被添加到名为`nextTickQueue`的队列中。在事件循环的任何阶段，如果`nextTickQueue`不为空，都会在当前阶段操作结束后优先执行`nextTickQueue`中的回调函数，当`nextTickQueue`中的回调函数执行完毕后，事件循环才会向下继续执行。

所以，如果nextTick的回调方法中出现了阻塞操作，那么后续的事件循环的过程也会被阻塞。

**process.nextTick和setImmediate**

`setImmediate`事件会在当前**事件循环**的结尾出发，对应的回调函数会在事件循环的`check`阶段执行。
`process.nextTick`会在当前事件循环阶段结束后立即执行，所以`process.nextTick`总是优先于`setImmediate`方法执行。

**setImmediate和setTimeout**


`setImmediate`会在当前**事件循环**的`poll`阶段结束后立即执行。然而，`setTimeout`会在规定的时间到期后执行。由于无法知道当前事件循环处于哪个阶段，所以这两者的执行顺序一般是不确定的。
但是，如果将两个操作放在一个`io callback`中，则永远是`setImmediate`方法先执行。
```js
const fs = require('fs)

fs.readFile('./package.json', () => {
    setTimeout(() => {
        console.log('setTimeout')
    }, 0)

    setImmediate(() => {
        console.log('setImmediate')
    })
})
```
因为`readFile`方法的回调函数执行的时候，事件循环处在`poll`阶段。这个阶段会先进入`check`阶段执行`setImmediate`方法的回调然后才会进入`timers`阶段执行`setTimeout`方法的回调。所以在这种情况下，永远是`setImmediate`方法先执行。
