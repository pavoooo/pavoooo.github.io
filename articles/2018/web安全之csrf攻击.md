# web安全之csrf攻击

`csrf`的全称是`Cross Site Request Forgery`，也就是我们通常所说的`跨站请求伪造`。

一般来说，`csrf`能够成功发起需要具备以下三个条件：

- 用户登录正常网站`A`，并登录。这个时候在网站`A`的`cookie`中已经保留有用户的登录信息。
- 在不登出网站`A`的情况下，访问危险网站`B`。
- 在危险网站`B`中向网站`A`发起请求。这个请求一般都会带上用户在`A`网站中的cookie信息。

下面是一个典型的`csrf`攻击的例子：

![csrf](/blog/csrf1.png)

上面的例子中，`csrf`能够攻击成功的原因就是`B`在向`A`网站的服务器发送请求的时候成功的带上了`A`网站的cookie信息。为了能够更好的防御`csrf`的攻击，我们需要对浏览器的cookie有一个简单的了解。

## Cookie

`Cookie`是浏览器用来保存信息的一种方式，主要是用来保存服务器下发给客户端的信息的。服务器通过`set-cookie`响应头部向客户端设置`cookie`。而客户端在向服务器进行请求的时候也会通过`cookie`请求头部携带自己保存的信息发给服务器。

浏览器的`cookie`一般分为两种：
- `Session Cookie`：也被称为`临时Cookie`
- `Third-party Cookir`：也被称为`本地Cookie`

两者的区别在于`本地cookie`在服务器通过`Set-cookie`头部设置`cookie`信息的时候会加上过期时间，也就是`Expire`字段，只有到了`Expire`指定的时间后`cookie`信息才会失效，这种`cookie`一般保存在本地。`临时Cookie`主要是用来保存用户的会话信息的，这种`Cookie`一般不会指定过期时间，它会存在于浏览器进程的生命周期内，及时浏览器打开了新的tab页，`Session Cookie`也是有效的。这种`Cookie`是保存在浏览器进程的内存空间内，会随着浏览器的关闭而销毁。

如果浏览器从一个域的页面中加载另一个域的页面，因为安全的原因，某些浏览器会阻止`本地cookie`的发送，但不会阻止`临时Cookie`的发送。

所以浏览器对于cookie的策略，对我们防御csrf的攻击具有很大的帮助。

## CSRF的防御

明白了`csrf`攻击的基本原理后，我们就需要去考虑怎么来防御这个比较奇特的攻击呢？业界比较流行的攻击手段主要有如下几种：

### 验证码

验证码被认为是防御`csrf`攻击最简洁和有效的手段。我们只需要在一些必要的场景下加入验证码的校验，就能在很大程度上预防`csrf`的攻击。

csrf攻击往往是在用户不知情的情况下发起的网络请求。而验证码强制必须和用户交互，才能完成最终的请求。但是验证码并不是万万不能的，为了良好的用户体验，我们不可能对每一个网络请求都加上验证码。所以，验证码对于预防`csrf`攻击只是一个辅助的手段，而不是一个最终的解决方案。

### referer检查

`referer`是http的一个请求头，主要是用来判断当前请求是从哪个网址发送过来的。如果判断出请求的`referer`字段不在我们允许的范围内，就极有可能是一个`csrf`攻击。但是，这种检查也是有一个很大的弊端的，**服务器并不是什么时候都能够取到`referer`**。很多用户出于隐私的保护，限制了`referer`字段的发送。当浏览器从`https`跳转到`http`的时候，也会出于安全的考虑，限制`referer`字段的发送。所以，这种防御手段也是一个可选的辅助方法，而不是一个终极解决方案。

### token验证
对于csrf攻击的防御，`token`验证算是一个比较统一的解决方案。

我们可以思考一下，`csrf`攻击为什么能够成功？

`csrf`攻击往往是在用户不知情的情况下向服务器发送请求，但是这个请求是如何构建出来的？所以，从本质上说，`csrf`攻击的本质原因就是**攻击者是可以猜出我们请求的参数的**。因为只有这样，攻击者才能构建出一个正确的请求。

知道这个原因后，我们就可以想到一个比较好的解决方案。比如，对参数进行加密，让攻击者无法正确理解参数的含义。或者在每次请求的时候，携带一个随机字符串，这样攻击者拿不到这个随机串，也就无法构造出正确的请求了。

`token`验证就是用来满足这种场景的。当我们向服务器请求资源的时候，服务器返回资源的同时向客户端下发一个token，客户端在每次请求的时候都需要带上这个token。服务器在收到请求后会先验证这个token的有效性。如果有效，会成功响应。否则，会拒绝响应。

这个`token`可以看作是客户端和服务器之间的一个凭证，所以，是不能让第三方知道的。一般我们可以将token保存在用户的session或者浏览器的cookie中。

### SameSite限制
上面几种预防方法只是从工程的角度出发尽可能的避免`csrf`的攻击。为了能从源头上解决`csrf`的攻击，http协议出了一个草案，就是在`set-cookie`中增加一个新的选项`SameSite`，这个选项表明这个cookie是一个`同站`cookie，是不能在第三方域名中进行发送的。

这个选项有两个值`Strict`和`Lax`。

#### SameSite=Strict
cookie的严格模式。表示这个cookie在任何情况下都不能在第三方的域名中进行发送。比如，我们在`a.com`中设置了如下cookie：

```css
Set-Cookie: foo=1; SameSite=Strict;
Set-Cookie: bar=2
```
如果在我们的`b.com`中存在一个对`a.com`的请求，那么foo这个cookie是不会包含在请求头中的，而bar却会。

#### SameSite=Lax
cookie的宽松模式。只会在使用危险HTTP方法发送跨域cookie的时候进行阻止，例如POST方式。比如下面两个场景：

- 在`a.com`中通过点击一个链接(get请求)，跳转到了`b.com`中。如果`b.com`设置了`SameSite=Lax`，这个请求是会带上这个cookie的。
- 在`a.com`中提交(post请求)一个表单到`b.com`中。如果`b.com`设置了`SameSite=Lax`，这个提交请求是不会带上这个cookie的。

> 如果我们的网站被设置在了一个iframe中，在SameSite=Lax的cookie同样不会被发送。